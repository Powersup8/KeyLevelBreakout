// © EMA Pullback Backtest Strategy
// Backtests pullback entries to 9 EMA after strong moves
// Short side (Puts): bull candle above EMA → bear pullback to EMA
// Long side (Calls): bear candle below EMA → bull pullback to EMA
// Designed for 5-min charts, ATR from Daily
//@version=6
strategy("EMA Pullback Backtest", overlay=true,
     default_qty_type=strategy.percent_of_equity, default_qty_value=100,
     initial_capital=10000, commission_type=strategy.commission.percent,
     commission_value=0.1, slippage=1)

// ─── Inputs ────────────────────────────────────────────────
i_enableShort  = input.bool(true,    "Enable Short (Puts)",       group="Direction")
i_enableLong   = input.bool(true,    "Enable Long (Calls)",       group="Direction")
i_qualShort    = input.string("Close", "Short Qualify Mode",      options=["Close", "High"], group="Direction")
i_qualLong     = input.string("Close", "Long Qualify Mode",       options=["Close", "Low"],  group="Direction")
i_retestMode   = input.string("EMA Touch", "Retest Mode",         options=["EMA Touch", "Any Opposite"], group="Direction")
i_signalTF     = input.timeframe("5", "Signal Timeframe",         group="Signals")
i_bodyFilter   = input.string("None", "Min Body %",               options=["None", "50%", "75%"], group="Parameters")
i_closeInval   = input.bool(true,    "Close Invalidation",        group="Parameters")
i_freshCross   = input.bool(true,    "Fresh Cross Filter",        group="Parameters")
i_retestWin    = input.string("1",   "Retest Window",             options=["1", "2", "3", "Any"], group="Parameters")
i_atrThresh    = input.float(20.0,   "ATR Threshold %",           minval=1.0, maxval=100.0, step=1.0, group="Parameters")
i_atrLen       = input.int(14,       "ATR Length (Daily)",         minval=1, group="Parameters")
i_emaLen       = input.int(9,        "EMA Length",                 minval=1, group="Parameters")

// ─── EMA ───────────────────────────────────────────────────
ema9 = ta.ema(close, i_emaLen)
plot(ema9, "9 EMA", color.new(color.yellow, 30), 1)

// ─── Daily ATR (non-repainting) ────────────────────────────
dailyATR = request.security(syminfo.tickerid, "D", ta.atr(i_atrLen)[1], lookahead=barmerge.lookahead_on)
atrOffset = dailyATR * i_atrThresh / 100.0

// ─── Signal Timeframe Data (confirmed bar only) ────────────
[sigO, sigH, sigL, sigC, sigPC] = request.security(syminfo.tickerid, i_signalTF,
     [open[1], high[1], low[1], close[1], close[2]], lookahead = barmerge.lookahead_on)
sigEma = request.security(syminfo.tickerid, i_signalTF, ta.ema(close, i_emaLen)[1], lookahead = barmerge.lookahead_on)

_sigT     = time(i_signalTF)
_sigChg   = ta.change(_sigT)
newSigBar = not na(_sigChg) and _sigChg != 0

shapeOff = -1

// ─── Signal-TF Candle Properties ────────────────────────────
sigIsBull = sigC > sigO
sigIsBear = sigC < sigO

// ─── SHORT SIDE (Puts) ────────────────────────────────────

// State: 0=SCANNING, 1=WAITING_FOR_PULLBACK, 2=IN_TRADE
var int   shortState     = 0
var float shortQualHigh  = na
var float shortQualLow   = na
var float shortQualClose = na
var int   shortQualAge   = 0
var bool  shortCrossed   = false
bool      shortEntered   = false

if i_enableShort and newSigBar
    if shortState == 0 or shortState == 1
        // Check for qualifying bullish candle
        qualAbove  = i_qualShort == "Close" ? sigC >= sigEma + atrOffset : sigH >= sigEma + atrOffset
        strongBody = i_bodyFilter == "None" ? true : math.abs(sigC - sigO) > (sigH - sigL) * (i_bodyFilter == "75%" ? 0.75 : 0.5)
        freshCross = not i_freshCross or sigPC <= sigEma
        if sigIsBull and qualAbove and strongBody and freshCross
            shortQualHigh  := sigH
            shortQualLow   := sigL
            shortQualClose := sigC
            shortQualAge   := 0
            shortState     := 1

    if shortState == 1
        shortQualAge += 1
        // Invalidate if EMA rose past qualifying candle's close
        if i_closeInval and shortQualClose <= sigEma
            shortState := 0
        // Check for bearish pullback (must be the next candle)
        shortRetest = i_retestMode == "EMA Touch" ? (sigIsBear and sigL <= sigEma) : sigIsBear
        if shortState == 1 and shortRetest
            entryPrice = shortQualHigh - (shortQualHigh - shortQualLow) / 3.0
            slPrice    = shortQualHigh
            strategy.entry("Short", strategy.short, limit=entryPrice)
            shortState   := 2
            shortCrossed := false
            shortEntered  = true
        else if i_retestWin != "Any" and shortQualAge > (i_retestWin == "1" ? 1 : i_retestWin == "2" ? 2 : 3)
            shortState := 0

    if shortState == 2 and not shortEntered
        if not shortCrossed and sigC < sigEma
            shortCrossed := true
        // Exit: SL (always active) or body above EMA (only after crossing)
        if sigH >= shortQualHigh
            strategy.close("Short", comment="SL")
            shortState := 0
        else if shortCrossed and math.min(sigO, sigC) > sigEma
            strategy.close("Short", comment="Exit")
            shortState := 0

// ─── LONG SIDE (Calls) ───────────────────────────────────

var int   longState     = 0
var float longQualHigh  = na
var float longQualLow   = na
var float longQualClose = na
var int   longQualAge   = 0
var bool  longCrossed   = false
bool      longEntered   = false

if i_enableLong and newSigBar
    if longState == 0 or longState == 1
        // Check for qualifying bearish candle
        qualBelow  = i_qualLong == "Close" ? sigC <= sigEma - atrOffset : sigL <= sigEma - atrOffset
        strongBody = i_bodyFilter == "None" ? true : math.abs(sigC - sigO) > (sigH - sigL) * (i_bodyFilter == "75%" ? 0.75 : 0.5)
        freshCross = not i_freshCross or sigPC >= sigEma
        if sigIsBear and qualBelow and strongBody and freshCross
            longQualHigh  := sigH
            longQualLow   := sigL
            longQualClose := sigC
            longQualAge   := 0
            longState     := 1

    if longState == 1
        longQualAge += 1
        // Invalidate if EMA dropped past qualifying candle's close
        if i_closeInval and longQualClose >= sigEma
            longState := 0
        // Check for bullish pullback (must be the next candle)
        longRetest = i_retestMode == "EMA Touch" ? (sigIsBull and sigH >= sigEma) : sigIsBull
        if longState == 1 and longRetest
            entryPrice = longQualLow + (longQualHigh - longQualLow) / 3.0
            slPrice    = longQualLow
            strategy.entry("Long", strategy.long, limit=entryPrice)
            longState   := 2
            longCrossed := false
            longEntered  = true
        else if i_retestWin != "Any" and longQualAge > (i_retestWin == "1" ? 1 : i_retestWin == "2" ? 2 : 3)
            longState := 0

    if longState == 2 and not longEntered
        if not longCrossed and sigC > sigEma
            longCrossed := true
        // Exit: SL (always active) or body below EMA (only after crossing)
        if sigL <= longQualLow
            strategy.close("Long", comment="SL")
            longState := 0
        else if longCrossed and math.max(sigO, sigC) < sigEma
            strategy.close("Long", comment="Exit")
            longState := 0

// ─── Plot Shapes ──────────────────────────────────────────
plotshape(i_enableShort and shortState[1] == 1 and shortState == 2,
     "Short Entry", shape.triangledown, location.abovebar, color.red, offset=shapeOff, size=size.small, text="Put")
plotshape(i_enableShort and shortState[1] == 2 and shortState == 0,
     "Short Exit", shape.triangleup, location.belowbar, color.orange, offset=shapeOff, size=size.small, text="Exit")
plotshape(i_enableLong and longState[1] == 1 and longState == 2,
     "Long Entry", shape.triangleup, location.belowbar, color.green, offset=shapeOff, size=size.small, text="Call")
plotshape(i_enableLong and longState[1] == 2 and longState == 0,
     "Long Exit", shape.triangledown, location.abovebar, color.orange, offset=shapeOff, size=size.small, text="Exit")
