// © Key Level Breakout Alert Indicator
// Detects bullish/bearish 5m candle closes through key levels
// Designed for US stocks (NYSE/NASDAQ) on 5-min charts
//@version=6
indicator("Key Level Breakout", overlay=true, max_labels_count=500)

// ─── Inputs ────────────────────────────────────────────────
i_showPM    = input.bool(true,  "Premarket High/Low",         group="Level Toggles")
i_showYest  = input.bool(true,  "Yesterday High/Low",         group="Level Toggles")
i_showWeek  = input.bool(true,  "Last Week High/Low",         group="Level Toggles")
i_showORB   = input.bool(true,  "ORB High/Low",               group="Level Toggles")
i_firstOnly = input.bool(true,  "Once Per Breakout", group="Signals")
i_signalTF  = input.timeframe("5", "Signal Timeframe",        group="Signals")
i_showLines = input.bool(false, "Show Level Lines",           group="Visuals")
i_fadeOld   = input.bool(true,  "Fade Old Labels",            group="Visuals")
i_fadeAge   = input.int(100,    "Fade After (bars)",           minval=10, group="Visuals")

// ─── Filter Inputs ──────────────────────────────────────
i_volFilter  = input.bool(true,  "Require Above-Avg Volume",    group="Filters")
i_volMode    = input.string("Signal TF SMA", "Volume Baseline", options=["Signal TF SMA", "Daily Average"], group="Filters")
i_volMult    = input.float(1.5,  "Volume Multiplier",           minval=0.5, step=0.1, group="Filters")
i_volLen     = input.int(20,     "Volume SMA Length",            minval=5, group="Filters")
i_atrBuf     = input.bool(true,  "Use ATR Buffer",              group="Filters")
i_atrPct     = input.float(5.0,  "Breakout Buffer (% of ATR)",  minval=0, step=1, group="Filters")
i_atrRearm   = input.float(3.0,  "Re-arm Buffer (% of ATR)",    minval=0, step=1, group="Filters")

i_closePos    = input.bool(true,  "Show Close Position %",           group="Quality")

i_confirm     = input.bool(true,  "Post-Breakout Confirmation",     group="Confirmation")
i_confirmBars = input.int(10,     "Confirmation Window (chart bars)", minval=3, maxval=30, group="Confirmation")

// ─── Session Detection (US Eastern) ───────────────────────
TZ           = "America/New_York"
isPremarket  = not na(time(timeframe.period, "0400-0930:23456", TZ))
isRegular    = not na(time(timeframe.period, "0930-1600:23456", TZ))
isORBwin     = not na(time(timeframe.period, "0930-0935:23456", TZ))
newPremarket = isPremarket and not isPremarket[1]
newRegular   = isRegular   and not isRegular[1]

// ─── Level Calculation ────────────────────────────────────

// Premarket High/Low — track during premarket, freeze at 9:30
var float pmHigh = na
var float pmLow  = na
if newPremarket
    pmHigh := high
    pmLow  := low
else if isPremarket
    pmHigh := math.max(pmHigh, high)
    pmLow  := math.min(pmLow, low)

// Yesterday High/Low (non-repainting)
yestHigh = request.security(syminfo.tickerid, "D", high[1], lookahead = barmerge.lookahead_on)
yestLow  = request.security(syminfo.tickerid, "D", low[1],  lookahead = barmerge.lookahead_on)

// Last Week High/Low (non-repainting)
weekHigh = request.security(syminfo.tickerid, "W", high[1], lookahead = barmerge.lookahead_on)
weekLow  = request.security(syminfo.tickerid, "W", low[1],  lookahead = barmerge.lookahead_on)

// Daily ATR + Average Volume (non-repainting)
dailyATR    = request.security(syminfo.tickerid, "D", ta.atr(14)[1], lookahead = barmerge.lookahead_on)
dailyVolSma = request.security(syminfo.tickerid, "D", ta.sma(volume, i_volLen)[1], lookahead = barmerge.lookahead_on)

// ORB High/Low — first 5-min bar(s) of regular session
var float orbHigh = na
var float orbLow  = na
if isORBwin
    if not isORBwin[1]
        orbHigh := high
        orbLow  := low
    else
        orbHigh := math.max(orbHigh, high)
        orbLow  := math.min(orbLow, low)

// ─── Breakout Flags (reset each regular session) ────────
var bool xPMH = false
var bool xPML = false
var bool xYH  = false
var bool xYL  = false
var bool xWH  = false
var bool xWL  = false
var bool xOH  = false
var bool xOL  = false

// ─── Post-Breakout Confirmation State ───────────────────
var label  lastBullLbl       = na
var string lastBullText      = ""
var float  lastBullLvl       = na
var int    lastBullStart     = 0
var int    lastBullState     = 0  // 0=none, 1=monitoring, 2=retest-confirmed, 3=time-confirmed, -1=failed
var int    prevBullConfState = 0

var label  lastBearLbl       = na
var string lastBearText      = ""
var float  lastBearLvl       = na
var int    lastBearStart     = 0
var int    lastBearState     = 0
var int    prevBearConfState = 0

if newRegular
    xPMH := false
    xPML := false
    xYH  := false
    xYL  := false
    xWH  := false
    xWL  := false
    xOH  := false
    xOL  := false
    // Reset confirmation state at session open
    if i_confirm
        lastBullState     := 0
        lastBearState     := 0
        prevBullConfState := 0
        prevBearConfState := 0

// ─── Signal Timeframe Data (confirmed bar only) ──────────
// Previous completed signal-TF bar's OHLC — non-repainting
[sigC, sigO, sigH, sigL, sigPC, sigPC2, sigVol, sigVolPrev, sigVolSma] = request.security(syminfo.tickerid, i_signalTF,
     [close[1], open[1], high[1], low[1], close[2], close[3], volume[1], volume[2], ta.sma(volume, i_volLen)[1]], lookahead = barmerge.lookahead_on)

// Detect when a new signal-TF bar starts (previous one just closed)
_sigT     = time(i_signalTF)
_sigChg   = ta.change(_sigT)
newSigBar = not na(_sigChg) and _sigChg != 0

// Offset shapes back by 1 so the marker sits on the candle where
// the signal-TF bar closed (breakout candle on 5m, last 1m of the
// 5m period on a 1m chart)
shapeOff = -1

// ─── Filter Computations ────────────────────────────────
breakBuf = i_atrBuf and not na(dailyATR) ? dailyATR * i_atrPct / 100.0 : 0.0
rearmBuf = i_atrBuf and not na(dailyATR) ? dailyATR * i_atrRearm / 100.0 : 0.0

tfSecs      = timeframe.in_seconds(i_signalTF)
barsPerDay  = tfSecs > 0 ? 23400.0 / tfSecs : 1.0
dailyBarVol = barsPerDay > 0 ? dailyVolSma / barsPerDay : na
volBase     = i_volMode == "Signal TF SMA" ? sigVolSma : dailyBarVol
volThreshold = not na(volBase) ? volBase * i_volMult : na
// Directional volume: borrow prior bar only if it moved in the same direction
sigVolBull   = sigPC > sigPC2 ? math.max(nz(sigVol), nz(sigVolPrev)) : nz(sigVol)
sigVolBear   = sigPC < sigPC2 ? math.max(nz(sigVol), nz(sigVolPrev)) : nz(sigVol)
volPassBull  = not i_volFilter or na(volThreshold) or sigVolBull > volThreshold
volPassBear  = not i_volFilter or na(volThreshold) or sigVolBear > volThreshold
volRatioBull = not na(volBase) and volBase > 0 ? sigVolBull / volBase : na
volRatioBear = not na(volBase) and volBase > 0 ? sigVolBear / volBase : na
bullVolStr   = i_volFilter and not na(volRatioBull) ? " " + str.tostring(volRatioBull, "#.#") + "x" : ""
bearVolStr   = i_volFilter and not na(volRatioBear) ? " " + str.tostring(volRatioBear, "#.#") + "x" : ""
bullVolAlpha = i_volFilter and not na(volRatioBull) ? math.max(0, math.round(60 - volRatioBull * 20)) : 0
bearVolAlpha = i_volFilter and not na(volRatioBear) ? math.max(0, math.round(60 - volRatioBear * 20)) : 0
bullColor    = color.new(color.green, bullVolAlpha)
bearColor    = color.new(color.red, bearVolAlpha)

// Close position: where did the close land within the bar's range? (0-100%)
sigRng       = sigH - sigL
bullClosePos = sigRng > 0 ? math.round((sigC - sigL) / sigRng * 100) : na
bearClosePos = sigRng > 0 ? math.round((sigH - sigC) / sigRng * 100) : na

// ─── Invalidation: re-arm when price closes back through level ──
if i_firstOnly and newSigBar
    if xPMH and not na(pmHigh) and sigC <= (pmHigh - rearmBuf)
        xPMH := false
    if xPML and not na(pmLow) and sigC >= (pmLow + rearmBuf)
        xPML := false
    if xYH and not na(yestHigh) and sigC <= (yestHigh - rearmBuf)
        xYH := false
    if xYL and not na(yestLow) and sigC >= (yestLow + rearmBuf)
        xYL := false
    if xWH and not na(weekHigh) and sigC <= (weekHigh - rearmBuf)
        xWH := false
    if xWL and not na(weekLow) and sigC >= (weekLow + rearmBuf)
        xWL := false
    if xOH and not na(orbHigh) and sigC <= (orbHigh - rearmBuf)
        xOH := false
    if xOL and not na(orbLow) and sigC >= (orbLow + rearmBuf)
        xOL := false

// ─── Breakout Helpers ─────────────────────────────────────
// 2-bar lookback: if EITHER of the two prior closes was on the other
// side of the level, the cross is valid.  This prevents a scenario
// where a bearish candle crosses the level first, making sigPC already
// past the level so the subsequent bullish breakout never fires.
bullBreak(float level) =>
    float effLvl = level + breakBuf
    not na(level) and isRegular and newSigBar and sigC > sigO
     and sigC > level and sigH > effLvl
     and (sigPC <= effLvl or sigPC2 <= effLvl) and volPassBull

bearBreak(float level) =>
    float effLvl = level - breakBuf
    not na(level) and isRegular and newSigBar and sigC < sigO
     and sigC < level and sigL < effLvl
     and (sigPC >= effLvl or sigPC2 >= effLvl) and volPassBear

// ─── Raw Signals ──────────────────────────────────────────
rBullPMH = i_showPM   and bullBreak(pmHigh)
rBearPML = i_showPM   and bearBreak(pmLow)
rBullYH  = i_showYest  and bullBreak(yestHigh)
rBearYL  = i_showYest  and bearBreak(yestLow)
rBullWH  = i_showWeek  and bullBreak(weekHigh)
rBearWL  = i_showWeek  and bearBreak(weekLow)
rBullOH  = i_showORB   and not isORBwin and bullBreak(orbHigh)
rBearOL  = i_showORB   and not isORBwin and bearBreak(orbLow)

// ─── Filtered Signals (suppressed when flag active) ──────
sigBullPMH = rBullPMH and (not i_firstOnly or not xPMH)
sigBearPML = rBearPML and (not i_firstOnly or not xPML)
sigBullYH  = rBullYH  and (not i_firstOnly or not xYH)
sigBearYL  = rBearYL  and (not i_firstOnly or not xYL)
sigBullWH  = rBullWH  and (not i_firstOnly or not xWH)
sigBearWL  = rBearWL  and (not i_firstOnly or not xWL)
sigBullOH  = rBullOH  and (not i_firstOnly or not xOH)
sigBearOL  = rBearOL  and (not i_firstOnly or not xOL)

// Update flags after signal evaluation
if rBullPMH
    xPMH := true
if rBearPML
    xPML := true
if rBullYH
    xYH := true
if rBearYL
    xYL := true
if rBullWH
    xWH := true
if rBearWL
    xWL := true
if rBullOH
    xOH := true
if rBearOL
    xOL := true

// ─── Combined Signals ────────────────────────────────────
anyBull     = sigBullPMH or sigBullYH or sigBullWH or sigBullOH
anyBear     = sigBearPML or sigBearYL or sigBearWL or sigBearOL
anyBreakout = anyBull or anyBear

// ─── Signal Labels (confluent levels merged) ────────────────
bullText = ""
if sigBullPMH
    bullText := bullText + (bullText != "" ? " + " : "") + "PM H"
if sigBullYH
    bullText := bullText + (bullText != "" ? " + " : "") + "Yest H"
if sigBullWH
    bullText := bullText + (bullText != "" ? " + " : "") + "Week H"
if sigBullOH
    bullText := bullText + (bullText != "" ? " + " : "") + "ORB H"

bearText = ""
if sigBearPML
    bearText := bearText + (bearText != "" ? " + " : "") + "PM L"
if sigBearYL
    bearText := bearText + (bearText != "" ? " + " : "") + "Yest L"
if sigBearWL
    bearText := bearText + (bearText != "" ? " + " : "") + "Week L"
if sigBearOL
    bearText := bearText + (bearText != "" ? " + " : "") + "ORB L"

// Close position suffix: "^78" = close at 78% toward the high
bullPosStr = i_closePos and not na(bullClosePos) ? " ^" + str.tostring(bullClosePos) : ""
bearPosStr = i_closePos and not na(bearClosePos) ? " v" + str.tostring(bearClosePos) : ""

bullCount = (sigBullPMH ? 1 : 0) + (sigBullYH ? 1 : 0) + (sigBullWH ? 1 : 0) + (sigBullOH ? 1 : 0)
bearCount = (sigBearPML ? 1 : 0) + (sigBearYL ? 1 : 0) + (sigBearWL ? 1 : 0) + (sigBearOL ? 1 : 0)

isOld = i_fadeOld and (last_bar_index - bar_index) > i_fadeAge

if bullText != ""
    string fullBullText = bullText + bullVolStr + bullPosStr
    label lbl = label.new(bar_index + shapeOff, na, fullBullText,
         yloc=yloc.belowbar, style=label.style_label_up,
         color=isOld ? color.new(color.gray, 90) : bullColor,
         textcolor=isOld ? color.new(color.gray, 70) : color.white,
         size=bullCount > 1 ? size.normal : size.small)
    if i_confirm and not isOld
        // Auto-promote previous monitoring to confirmed (survived until next signal)
        if lastBullState == 1
            lastBullState := 3
            label.set_text(lastBullLbl, lastBullText + " ✓")
        // Track most conservative level (lowest for bull = hardest to hold)
        float lvl = na
        if sigBullPMH
            lvl := na(lvl) ? pmHigh : math.min(lvl, pmHigh)
        if sigBullYH
            lvl := na(lvl) ? yestHigh : math.min(lvl, yestHigh)
        if sigBullWH
            lvl := na(lvl) ? weekHigh : math.min(lvl, weekHigh)
        if sigBullOH
            lvl := na(lvl) ? orbHigh : math.min(lvl, orbHigh)
        lastBullLbl   := lbl
        lastBullText  := fullBullText
        lastBullLvl   := lvl
        lastBullStart := bar_index
        lastBullState := 1

if bearText != ""
    string fullBearText = bearText + bearVolStr + bearPosStr
    label lbl = label.new(bar_index + shapeOff, na, fullBearText,
         yloc=yloc.abovebar, style=label.style_label_down,
         color=isOld ? color.new(color.gray, 90) : bearColor,
         textcolor=isOld ? color.new(color.gray, 70) : color.white,
         size=bearCount > 1 ? size.normal : size.small)
    if i_confirm and not isOld
        if lastBearState == 1
            lastBearState := 3
            label.set_text(lastBearLbl, lastBearText + " ✓")
        float lvl = na
        if sigBearPML
            lvl := na(lvl) ? pmLow : math.max(lvl, pmLow)
        if sigBearYL
            lvl := na(lvl) ? yestLow : math.max(lvl, yestLow)
        if sigBearWL
            lvl := na(lvl) ? weekLow : math.max(lvl, weekLow)
        if sigBearOL
            lvl := na(lvl) ? orbLow : math.max(lvl, orbLow)
        lastBearLbl   := lbl
        lastBearText  := fullBearText
        lastBearLvl   := lvl
        lastBearStart := bar_index
        lastBearState := 1

// ─── Post-Breakout Confirmation Monitoring ────────────────
// Runs every chart bar (not gated by newSigBar) for real-time feedback.
if i_confirm and lastBullState == 1 and not na(lastBullLvl)
    int elapsed = bar_index - lastBullStart
    if close < lastBullLvl - rearmBuf
        lastBullState := -1
        label.set_text(lastBullLbl, lastBullText + " ✗")
        label.set_color(lastBullLbl, color.new(color.gray, 60))
        label.set_textcolor(lastBullLbl, color.new(color.gray, 40))
    else if elapsed >= 2 and low <= lastBullLvl + rearmBuf and close > lastBullLvl
        lastBullState := 2
        label.set_text(lastBullLbl, lastBullText + " ⟳✓")
    else if elapsed >= i_confirmBars
        lastBullState := 3
        label.set_text(lastBullLbl, lastBullText + " ✓")

if i_confirm and lastBearState == 1 and not na(lastBearLvl)
    int elapsed = bar_index - lastBearStart
    if close > lastBearLvl + rearmBuf
        lastBearState := -1
        label.set_text(lastBearLbl, lastBearText + " ✗")
        label.set_color(lastBearLbl, color.new(color.gray, 60))
        label.set_textcolor(lastBearLbl, color.new(color.gray, 40))
    else if elapsed >= 2 and high >= lastBearLvl - rearmBuf and close < lastBearLvl
        lastBearState := 2
        label.set_text(lastBearLbl, lastBearText + " ⟳✓")
    else if elapsed >= i_confirmBars
        lastBearState := 3
        label.set_text(lastBearLbl, lastBearText + " ✓")

// Confirmation alerts (fire once per state transition)
if i_confirm
    if lastBullState != prevBullConfState
        if lastBullState == 2 or lastBullState == 3
            alert("Confirmed: " + lastBullText, alert.freq_once_per_bar_close)
        if lastBullState == -1
            alert("Failed: " + lastBullText, alert.freq_once_per_bar_close)
        prevBullConfState := lastBullState
    if lastBearState != prevBearConfState
        if lastBearState == 2 or lastBearState == 3
            alert("Confirmed: " + lastBearText, alert.freq_once_per_bar_close)
        if lastBearState == -1
            alert("Failed: " + lastBearText, alert.freq_once_per_bar_close)
        prevBearConfState := lastBearState

// ─── Level Lines (optional, off by default) ───────────────
plot(i_showLines and i_showPM   and isRegular ? pmHigh   : na, "PM High",   color.new(color.orange, 40), 1, plot.style_linebr)
plot(i_showLines and i_showPM   and isRegular ? pmLow    : na, "PM Low",    color.new(color.orange, 40), 1, plot.style_linebr)
plot(i_showLines and i_showYest and isRegular ? yestHigh : na, "Yest High", color.new(color.blue, 40),   1, plot.style_linebr)
plot(i_showLines and i_showYest and isRegular ? yestLow  : na, "Yest Low",  color.new(color.blue, 40),   1, plot.style_linebr)
plot(i_showLines and i_showWeek and isRegular ? weekHigh : na, "Week High", color.new(color.purple, 40), 1, plot.style_linebr)
plot(i_showLines and i_showWeek and isRegular ? weekLow  : na, "Week Low",  color.new(color.purple, 40), 1, plot.style_linebr)
plot(i_showLines and i_showORB  and isRegular ? orbHigh  : na, "ORB High",  color.new(color.teal, 40),   1, plot.style_linebr)
plot(i_showLines and i_showORB  and isRegular ? orbLow   : na, "ORB Low",   color.new(color.teal, 40),   1, plot.style_linebr)

// ─── Programmatic Alerts (merged like labels) ───────────
if bullText != ""
    alert("Bullish breakout: " + bullText + bullVolStr + bullPosStr, alert.freq_once_per_bar_close)
if bearText != ""
    alert("Bearish breakout: " + bearText + bearVolStr + bearPosStr, alert.freq_once_per_bar_close)

// ─── Alert Conditions ───────────────────────────────────────
// Note: per-level alertconditions removed — "Any alert() function call"
// catches both alert() and alertcondition(), causing duplicate notifications.
// Use "Any alert() function call" for merged alerts (recommended).
// Use the conditions below for simple bull/bear/any filtering.
alertcondition(anyBull,     "Any Bullish Breakout",       "Bullish breakout detected")
alertcondition(anyBear,     "Any Bearish Breakout",       "Bearish breakout detected")
alertcondition(anyBreakout, "Any Breakout",               "Breakout detected (bull or bear)")
