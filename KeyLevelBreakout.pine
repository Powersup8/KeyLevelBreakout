// © Key Level Breakout Alert Indicator
// Detects bullish/bearish 5m candle closes through key levels
// Designed for US stocks (NYSE/NASDAQ) on 5-min charts
//@version=6
indicator("Key Level Breakout", overlay=true, max_labels_count=500)

// ─── Inputs ────────────────────────────────────────────────
i_showPM    = input.bool(true,  "Premarket High/Low",         group="Level Toggles")
i_showYest  = input.bool(true,  "Yesterday High/Low",         group="Level Toggles")
i_showWeek  = input.bool(true,  "Last Week High/Low",         group="Level Toggles")
i_showORB   = input.bool(true,  "ORB High/Low",               group="Level Toggles")
i_firstOnly = input.bool(true,  "Once Per Breakout", group="Signals")
i_signalTF  = input.timeframe("5", "Signal Timeframe",        group="Signals")
i_showLines = input.bool(false, "Show Level Lines",           group="Visuals")
i_fadeOld   = input.bool(true,  "Fade Old Labels",            group="Visuals")
i_fadeAge   = input.int(100,    "Fade After (signal bars)",    minval=10, group="Visuals")

// ─── Filter Inputs ──────────────────────────────────────
i_volFilter  = input.bool(true,  "Require Above-Avg Volume",    group="Filters")
i_volMode    = input.string("Signal TF SMA", "Volume Baseline", options=["Signal TF SMA", "Daily Average"], group="Filters")
i_volMult    = input.float(1.5,  "Volume Multiplier",           minval=0.5, step=0.1, group="Filters")
i_volLen     = input.int(20,     "Volume SMA Length",            minval=5, group="Filters")
i_atrBuf     = input.bool(true,  "Use ATR Buffer",              group="Filters")
i_atrPct     = input.float(5.0,  "Breakout Buffer (% of ATR)",  minval=0, step=1, group="Filters")
i_atrRearm   = input.float(3.0,  "Re-arm Buffer (% of ATR)",    minval=0, step=1, group="Filters")

i_closePos    = input.bool(true,  "Show Close Position %",           group="Quality")

i_confirm     = input.bool(true,  "Post-Breakout Confirmation",     group="Confirmation")
i_retestWindow = input.string("Session", "Retest Window", options=["Short (50 min)", "Extended (2.5 hr)", "Session"], group="Confirmation")
i_retestProx   = input.float(3.0, "Retest Proximity (% of ATR)", minval=0.5, step=0.5, group="Confirmation")
i_retestOnly  = input.bool(false, "Retest-Only Mode",                group="Signals")
i_cooldownBars = input.int(2, "Signal Cooldown (signal bars)", minval=0, maxval=10, group="Signals")

// ─── Setup Inputs ──────────────────────────────────────
i_showReversal = input.bool(true,   "Show Reversal Setups",            group="Setups")
i_limitRevWin  = input.bool(false,  "Limit Reversal Window",           group="Setups")
i_showReclaim  = input.bool(true,   "Show Reclaim Setups",             group="Setups")
i_setupWindow  = input.string("0930-1130", "Setup Active Window (ET)", group="Setups")

i_vwapFilter   = input.bool(false,  "VWAP Directional Filter (reversals)", tooltip="Suppress bear reversals above VWAP, bull reversals below VWAP", group="Filters")

i_useZones     = input.bool(true,   "Use Level Zones (wick-to-body)",  group="Zones")
i_zoneATRPct   = input.float(3.0,   "Zone Width for PM/ORB (% of ATR)", minval=0, step=0.5, group="Zones")

i_revPM   = input.bool(true, "PM H/L Reversal/Reclaim",   group="Reversal/Reclaim Toggles")
i_revYest = input.bool(true, "Yest H/L Reversal/Reclaim", group="Reversal/Reclaim Toggles")
i_revWeek = input.bool(true, "Week H/L Reversal/Reclaim", group="Reversal/Reclaim Toggles")
i_revORB  = input.bool(true, "ORB H/L Reversal/Reclaim",  group="Reversal/Reclaim Toggles")

// ─── Debug Inputs ─────────────────────────────────────
i_debugTable = input.bool(false, "Show Signal Table",        group="Debug")
i_debugLog   = input.bool(false, "Log Signals (Pine Logs)",  group="Debug")
i_debugPos   = input.string("bottom_right", "Table Position",
    options=["top_left","top_center","top_right",
             "bottom_left","bottom_center","bottom_right"], group="Debug")
i_debugRows  = input.int(20, "Max Table Rows", minval=5, maxval=50, group="Debug")

// ─── Session Detection (US Eastern) ───────────────────────
TZ           = "America/New_York"
isPremarket  = not na(time(timeframe.period, "0400-0930:23456", TZ))
isRegular    = not na(time(timeframe.period, "0930-1600:23456", TZ))
isORBwin     = not na(time(timeframe.period, "0930-0935:23456", TZ))
newPremarket = isPremarket and not isPremarket[1]
newRegular   = isRegular   and not isRegular[1]
isSetupWindow = not na(time(timeframe.period, i_setupWindow + ":23456", TZ))

// ─── Level Calculation ────────────────────────────────────

// Premarket High/Low — track during premarket, freeze at 9:30
var float pmHigh = na
var float pmLow  = na
if newPremarket
    pmHigh := high
    pmLow  := low
else if isPremarket
    pmHigh := math.max(pmHigh, high)
    pmLow  := math.min(pmLow, low)

// Yesterday OHLC (non-repainting) — tuple reduces request.security calls
[yestHigh, yestLow, yestOpen, yestClose] = request.security(syminfo.tickerid, "D",
     [high[1], low[1], open[1], close[1]], lookahead = barmerge.lookahead_on)

// Last Week OHLC (non-repainting) — tuple reduces request.security calls
[weekHigh, weekLow, weekOpen, weekClose] = request.security(syminfo.tickerid, "W",
     [high[1], low[1], open[1], close[1]], lookahead = barmerge.lookahead_on)

// Daily ATR + Average Volume (non-repainting)
dailyATR    = request.security(syminfo.tickerid, "D", ta.atr(14)[1], lookahead = barmerge.lookahead_on)
dailyVolSma = request.security(syminfo.tickerid, "D", ta.sma(volume, i_volLen)[1], lookahead = barmerge.lookahead_on)

// ORB High/Low — first 5-min bar(s) of regular session
var float orbHigh = na
var float orbLow  = na
if isORBwin
    if not isORBwin[1]
        orbHigh := high
        orbLow  := low
    else
        orbHigh := math.max(orbHigh, high)
        orbLow  := math.min(orbLow, low)

// ─── Zone Bounds ───────────────────────────────────────
// D/W levels: body edge from candle OHLC. PM/ORB: ATR-derived width.
// When zones OFF: body = wick (zone collapses to single line).
zoneWidth = i_useZones and not na(dailyATR) ? dailyATR * i_zoneATRPct / 100.0 : 0.0
pmHBody   = i_useZones ? pmHigh - zoneWidth : pmHigh
pmLBody   = i_useZones ? pmLow  + zoneWidth : pmLow
yestHBody = i_useZones and not na(yestOpen) ? math.max(yestOpen, yestClose) : yestHigh
yestLBody = i_useZones and not na(yestOpen) ? math.min(yestOpen, yestClose) : yestLow
weekHBody = i_useZones and not na(weekOpen) ? math.max(weekOpen, weekClose) : weekHigh
weekLBody = i_useZones and not na(weekOpen) ? math.min(weekOpen, weekClose) : weekLow
orbHBody  = i_useZones ? orbHigh - zoneWidth : orbHigh
orbLBody  = i_useZones ? orbLow  + zoneWidth : orbLow

// ─── Breakout Flags (reset each regular session) ────────
var bool xPMH = false
var bool xPML = false
var bool xYH  = false
var bool xYL  = false
var bool xWH  = false
var bool xWL  = false
var bool xOH  = false
var bool xOL  = false

// ─── Reversal Flags (reset each regular session) ──────
var bool rPMH = false
var bool rPML = false
var bool rYH  = false
var bool rYL  = false
var bool rWH  = false
var bool rWL  = false
var bool rOH  = false
var bool rOL  = false

// ─── Reclaim Context (was this level broken + invalidated?) ──
var bool hadBrkPMH = false
var bool hadBrkPML = false
var bool hadBrkYH  = false
var bool hadBrkYL  = false
var bool hadBrkWH  = false
var bool hadBrkWL  = false
var bool hadBrkOH  = false
var bool hadBrkOL  = false

// ─── Reversal Label Tracking (gray out prior on supersede) ──
var label revLblPML = na
var label revLblYL  = na
var label revLblWL  = na
var label revLblOL  = na
var label revLblPMH = na
var label revLblYH  = na
var label revLblWH  = na
var label revLblOH  = na

// ─── Post-Breakout Confirmation State ───────────────────
// Per-level retest tracking: 4 bull levels (PMH,YH,WH,OH), 4 bear (PML,YL,WL,OL)
var bool[]   bRT     = array.new_bool(4, false)   // retested?
var int[]    bRTBar  = array.new_int(4, 0)        // bar of retest
var string[] bRTInfo = array.new_string(4, "")    // quality string at retest
var float[]  bRTLvl  = array.new_float(4, na)     // level value being tracked
var label    bRTLbl  = na                          // breakout label ref
var string   bRTBase = ""                          // base label text
var int      bRTStart = 0                          // bar_index of breakout
var float    bRTConsLvl = na                       // most conservative level (lowest for bull)
var int      bRTState = 0                          // 0=none, 1=monitoring, -1=failed
var int      bRTPrev  = 0                          // previous state (for alert transitions)
var int      bRTBar0  = 0                          // chart-TF bar_index of breakout (skip self-retest)

var bool[]   sRT     = array.new_bool(4, false)
var int[]    sRTBar  = array.new_int(4, 0)
var string[] sRTInfo = array.new_string(4, "")
var float[]  sRTLvl  = array.new_float(4, na)
var label    sRTLbl  = na
var string   sRTBase = ""
var int      sRTStart = 0
var float    sRTConsLvl = na
var int      sRTState = 0
var int      sRTPrev  = 0
var int      sRTBar0  = 0                          // chart-TF bar_index of breakout (skip self-retest)

// ─── Debug Signal Log Arrays ─────────────────────────
var array<int>    dbTime       = array.new<int>()
var array<string> dbDir        = array.new<string>()
var array<string> dbType       = array.new<string>()
var array<string> dbLevels     = array.new<string>()
var array<float>  dbVol        = array.new<float>()
var array<int>    dbClsPos     = array.new<int>()
var array<string> dbConf       = array.new<string>()
var array<string> dbOHLC       = array.new<string>()
// Log-only extended data
var array<float>  dbATR        = array.new<float>()
var array<float>  dbVolRaw     = array.new<float>()
var array<float>  dbVolSMA     = array.new<float>()
var array<float>  dbBuffer     = array.new<float>()
var array<string> dbLvlPrices  = array.new<string>()
// Confirmation tracking indices
var int dbConfBullIdx = -1
var int dbConfBearIdx = -1
// Table object (persists across ticks, deleted+recreated on last bar)
var table dbTbl = na

if newRegular
    xPMH := false
    xPML := false
    xYH  := false
    xYL  := false
    xWH  := false
    xWL  := false
    xOH  := false
    xOL  := false
    // Reset reversal flags
    rPMH := false
    rPML := false
    rYH  := false
    rYL  := false
    rWH  := false
    rWL  := false
    rOH  := false
    rOL  := false
    // Reset reclaim context
    hadBrkPMH := false
    hadBrkPML := false
    hadBrkYH  := false
    hadBrkYL  := false
    hadBrkWH  := false
    hadBrkWL  := false
    hadBrkOH  := false
    hadBrkOL  := false
    // Reset reversal label tracking
    revLblPML := na
    revLblYL  := na
    revLblWL  := na
    revLblOL  := na
    revLblPMH := na
    revLblYH  := na
    revLblWH  := na
    revLblOH  := na
    // Reset per-level retest state at session open
    if i_confirm
        for i = 0 to 3
            array.set(bRT, i, false)
            array.set(bRTLvl, i, na)
            array.set(sRT, i, false)
            array.set(sRTLvl, i, na)
        bRTState := 0
        bRTPrev  := 0
        sRTState := 0
        sRTPrev  := 0
    // Reset debug arrays at session open
    if i_debugTable or i_debugLog
        array.clear(dbTime)
        array.clear(dbDir)
        array.clear(dbType)
        array.clear(dbLevels)
        array.clear(dbVol)
        array.clear(dbClsPos)
        array.clear(dbConf)
        array.clear(dbOHLC)
        array.clear(dbATR)
        array.clear(dbVolRaw)
        array.clear(dbVolSMA)
        array.clear(dbBuffer)
        array.clear(dbLvlPrices)
        dbConfBullIdx := -1
        dbConfBearIdx := -1

// ─── Signal Timeframe Data (confirmed bar only) ──────────
// Previous completed signal-TF bar's OHLC — non-repainting
[sigC, sigO, sigH, sigL, sigPC, sigPC2, sigVol, sigVolPrev, sigVolSma] = request.security(syminfo.tickerid, i_signalTF,
     [close[1], open[1], high[1], low[1], close[2], close[3], volume[1], volume[2], ta.sma(volume, i_volLen)[1]], lookahead = barmerge.lookahead_on)

// Detect when a new signal-TF bar starts (previous one just closed)
_sigT     = time(i_signalTF)
_sigChg   = ta.change(_sigT)
newSigBar = not na(_sigChg) and _sigChg != 0

// Offset shapes back by 1 so the marker sits on the candle where
// the signal-TF bar closed (breakout candle on 5m, last 1m of the
// 5m period on a 1m chart)
shapeOff = -1

// Signal-TF bar counter — ensures bar counts & monitoring are chart-TF independent
var int sigBarIdx = 0
if newSigBar
    sigBarIdx += 1

// ─── Filter Computations ────────────────────────────────
vwapVal  = ta.vwap
breakBuf = i_atrBuf and not na(dailyATR) ? dailyATR * i_atrPct / 100.0 : 0.0
rearmBuf = i_atrBuf and not na(dailyATR) ? dailyATR * i_atrRearm / 100.0 : 0.0
retestBuf      = not na(dailyATR) ? dailyATR * i_retestProx / 100.0 : rearmBuf
retestMaxElapsed = i_retestWindow == "Short (50 min)" ? 10 : i_retestWindow == "Extended (2.5 hr)" ? 30 : 99999

tfSecs      = timeframe.in_seconds(i_signalTF)
barsPerDay  = tfSecs > 0 ? 23400.0 / tfSecs : 1.0
dailyBarVol = barsPerDay > 0 ? dailyVolSma / barsPerDay : na
volBase     = i_volMode == "Signal TF SMA" ? sigVolSma : dailyBarVol
volThreshold = not na(volBase) ? volBase * i_volMult : na
// Directional volume: borrow prior bar only if it moved in the same direction
sigVolBull   = sigPC > sigPC2 ? math.max(nz(sigVol), nz(sigVolPrev)) : nz(sigVol)
sigVolBear   = sigPC < sigPC2 ? math.max(nz(sigVol), nz(sigVolPrev)) : nz(sigVol)
volPassBull  = not i_volFilter or na(volThreshold) or sigVolBull > volThreshold
volPassBear  = not i_volFilter or na(volThreshold) or sigVolBear > volThreshold
volRatioBull = not na(volBase) and volBase > 0 ? sigVolBull / volBase : na
volRatioBear = not na(volBase) and volBase > 0 ? sigVolBear / volBase : na
bullVolAlpha = i_volFilter and not na(volRatioBull) ? math.max(0, math.round(35 - volRatioBull * 10)) : 0
bearVolAlpha = i_volFilter and not na(volRatioBear) ? math.max(0, math.round(35 - volRatioBear * 10)) : 0
bullColor    = color.new(color.green, bullVolAlpha)
bearColor    = color.new(color.red, bearVolAlpha)

// Close position: where did the close land within the bar's range? (0-100%)
sigRng       = sigH - sigL
bullClosePos = sigRng > 0 ? math.round((sigC - sigL) / sigRng * 100) : na
bearClosePos = sigRng > 0 ? math.round((sigH - sigC) / sigRng * 100) : na

// ─── Helper: integer to superscript string ──────────────
toSup(int n) =>
    string s = str.tostring(n)
    string r = ""
    for i = 0 to str.length(s) - 1
        string c = str.substring(s, i, i + 1)
        r += c == "0" ? "⁰" : c == "1" ? "¹" : c == "2" ? "²" : c == "3" ? "³" : c == "4" ? "⁴" : c == "5" ? "⁵" : c == "6" ? "⁶" : c == "7" ? "⁷" : c == "8" ? "⁸" : "⁹"
    r

// ─── Helper: signal-TF quality string (for breakout labels) ─────
sigQual(bool isBull) =>
    float vr = isBull ? volRatioBull : volRatioBear
    string vol = not na(vr) ? str.tostring(vr, "#.#") + "x" : ""
    int pos = isBull ? bullClosePos : bearClosePos
    string pa = not na(pos) ? (isBull ? "^" : "v") + str.tostring(pos) : ""
    vol + (vol != "" and pa != "" ? " " : "") + pa

// ─── Helper: chart-TF quality string (for retests) ─────
chartQual(bool isBull) =>
    float rng = high - low
    float vr = not na(volBase) and volBase > 0 ? volume / volBase : na
    string vol = not na(vr) ? str.tostring(vr, "#.#") + "x" : ""
    int pos = rng > 0 ? math.round((isBull ? (close - low) : (high - close)) / rng * 100) : na
    string pa = not na(pos) ? (isBull ? "^" : "v") + str.tostring(pos) : ""
    vol + (vol != "" and pa != "" ? " " : "") + pa

// ─── Debug: format time as HH:MM ET ─────────────────
fmtTime(int t) =>
    int h = hour(t, "America/New_York")
    int m = minute(t, "America/New_York")
    str.tostring(h) + ":" + (m < 10 ? "0" : "") + str.tostring(m)

// ─── Debug: append signal to arrays + optional log ───
dbAppend(string dir, string typ, string levels, float vol, int clsPos, string conf, string lvlPrices) =>
    if i_debugTable or i_debugLog
        array.push(dbTime, time)
        array.push(dbDir, dir)
        array.push(dbType, typ)
        array.push(dbLevels, levels)
        array.push(dbVol, vol)
        array.push(dbClsPos, clsPos)
        array.push(dbConf, conf)
        string ohlc = "O" + str.tostring(sigO, "#.##") + " H" + str.tostring(sigH, "#.##") + " L" + str.tostring(sigL, "#.##") + " C" + str.tostring(sigC, "#.##")
        array.push(dbOHLC, ohlc)
        array.push(dbATR, nz(dailyATR))
        array.push(dbVolRaw, nz(sigVol))
        array.push(dbVolSMA, nz(volBase))
        array.push(dbBuffer, breakBuf)
        array.push(dbLvlPrices, lvlPrices)
        if i_debugLog and barstate.isconfirmed
            string posStr = na(clsPos) ? "" : (dir == "▲" ? "^" : "v") + str.tostring(clsPos)
            string volStr = na(vol) ? "" : str.tostring(vol, "#.#") + "x"
            string msg = "[KLB] " + fmtTime(time) + " " + dir + " " + typ + " " + levels + " vol=" + volStr + " pos=" + posStr + " " + ohlc + " ATR=" + str.tostring(nz(dailyATR), "#.##") + " rawVol=" + str.tostring(nz(sigVol), "#") + " volSMA=" + str.tostring(nz(volBase), "#") + " buf=" + str.tostring(breakBuf, "#.###") + " prices=" + lvlPrices
            log.info(msg)
    array.size(dbTime) - 1

// ─── Debug: build level prices string for a signal ───
dbLvlPriceStr(bool isPMH, bool isPML, bool isYH, bool isYL, bool isWH, bool isWL, bool isOH, bool isOL) =>
    string s = ""
    if isPMH and not na(pmHigh)
        s += (s != "" ? "/" : "") + str.tostring(pmHigh, "#.##")
    if isPML and not na(pmLow)
        s += (s != "" ? "/" : "") + str.tostring(pmLow, "#.##")
    if isYH and not na(yestHigh)
        s += (s != "" ? "/" : "") + str.tostring(yestHigh, "#.##")
    if isYL and not na(yestLow)
        s += (s != "" ? "/" : "") + str.tostring(yestLow, "#.##")
    if isWH and not na(weekHigh)
        s += (s != "" ? "/" : "") + str.tostring(weekHigh, "#.##")
    if isWL and not na(weekLow)
        s += (s != "" ? "/" : "") + str.tostring(weekLow, "#.##")
    if isOH and not na(orbHigh)
        s += (s != "" ? "/" : "") + str.tostring(orbHigh, "#.##")
    if isOL and not na(orbLow)
        s += (s != "" ? "/" : "") + str.tostring(orbLow, "#.##")
    s

// Level name arrays for retest label building
bullLvlNames = array.from("PM H", "Yest H", "Week H", "ORB H")
bearLvlNames = array.from("PM L", "Yest L", "Week L", "ORB L")

// ─── Invalidation: re-arm when price closes back through level ──
if i_firstOnly and newSigBar
    if xPMH and not na(pmHigh) and sigC <= (pmHigh - rearmBuf)
        xPMH := false
        hadBrkPMH := true
    if xPML and not na(pmLow) and sigC >= (pmLow + rearmBuf)
        xPML := false
        hadBrkPML := true
    if xYH and not na(yestHigh) and sigC <= (yestHigh - rearmBuf)
        xYH := false
        hadBrkYH := true
    if xYL and not na(yestLow) and sigC >= (yestLow + rearmBuf)
        xYL := false
        hadBrkYL := true
    if xWH and not na(weekHigh) and sigC <= (weekHigh - rearmBuf)
        xWH := false
        hadBrkWH := true
    if xWL and not na(weekLow) and sigC >= (weekLow + rearmBuf)
        xWL := false
        hadBrkWL := true
    if xOH and not na(orbHigh) and sigC <= (orbHigh - rearmBuf)
        xOH := false
        hadBrkOH := true
    if xOL and not na(orbLow) and sigC >= (orbLow + rearmBuf)
        xOL := false
        hadBrkOL := true
    // Reversal re-arm: price moved decisively away from the rejection zone
    if rPMH and not na(pmHigh) and sigC > (pmHigh + rearmBuf)
        rPMH := false
    if rPML and not na(pmLow) and sigC < (pmLow - rearmBuf)
        rPML := false
    if rYH and not na(yestHigh) and sigC > (yestHigh + rearmBuf)
        rYH := false
    if rYL and not na(yestLow) and sigC < (yestLow - rearmBuf)
        rYL := false
    if rWH and not na(weekHigh) and sigC > (weekHigh + rearmBuf)
        rWH := false
    if rWL and not na(weekLow) and sigC < (weekLow - rearmBuf)
        rWL := false
    if rOH and not na(orbHigh) and sigC > (orbHigh + rearmBuf)
        rOH := false
    if rOL and not na(orbLow) and sigC < (orbLow - rearmBuf)
        rOL := false

// ─── Breakout Helpers ─────────────────────────────────────
// 2-bar lookback: if EITHER of the two prior closes was on the other
// side of the level, the cross is valid.  This prevents a scenario
// where a bearish candle crosses the level first, making sigPC already
// past the level so the subsequent bullish breakout never fires.
bullBreak(float level) =>
    float effLvl = level + breakBuf
    not na(level) and isRegular and newSigBar and sigC > sigO
     and sigC > level and sigH > effLvl
     and (sigPC <= effLvl or sigPC2 <= effLvl) and volPassBull

bearBreak(float level) =>
    float effLvl = level - breakBuf
    not na(level) and isRegular and newSigBar and sigC < sigO
     and sigC < level and sigL < effLvl
     and (sigPC >= effLvl or sigPC2 >= effLvl) and volPassBear

// ─── Reversal Helpers ───────────────────────────────────
// Bull reversal at LOW level: wick dips into zone, close rejects above body edge.
// Bear reversal at HIGH level: wick pushes into zone, close rejects below body edge.
bullRev(float wick, float body) =>
    not na(wick) and not na(body) and isRegular and newSigBar
     and (not i_limitRevWin or isSetupWindow)
     and sigC > sigO and sigL <= body and sigC > body and volPassBull
     and (not i_vwapFilter or not na(vwapVal) and sigC > vwapVal)

bearRev(float wick, float body) =>
    not na(wick) and not na(body) and isRegular and newSigBar
     and (not i_limitRevWin or isSetupWindow)
     and sigC < sigO and sigH >= body and sigC < body and volPassBear
     and (not i_vwapFilter or not na(vwapVal) and sigC < vwapVal)

// ─── Raw Signals ──────────────────────────────────────────
rBullPMH = i_showPM   and bullBreak(pmHigh)
rBearPML = i_showPM   and bearBreak(pmLow)
rBullYH  = i_showYest  and bullBreak(yestHigh)
rBearYL  = i_showYest  and bearBreak(yestLow)
rBullWH  = i_showWeek  and bullBreak(weekHigh)
rBearWL  = i_showWeek  and bearBreak(weekLow)
rBullOH  = i_showORB   and not isORBwin and bullBreak(orbHigh)
rBearOL  = i_showORB   and not isORBwin and bearBreak(orbLow)

// ─── Filtered Signals (suppressed when flag active) ──────
sigBullPMH = rBullPMH and (not i_firstOnly or not xPMH)
sigBearPML = rBearPML and (not i_firstOnly or not xPML)
sigBullYH  = rBullYH  and (not i_firstOnly or not xYH)
sigBearYL  = rBearYL  and (not i_firstOnly or not xYL)
sigBullWH  = rBullWH  and (not i_firstOnly or not xWH)
sigBearWL  = rBearWL  and (not i_firstOnly or not xWL)
sigBullOH  = rBullOH  and (not i_firstOnly or not xOH)
sigBearOL  = rBearOL  and (not i_firstOnly or not xOL)

// Update flags after signal evaluation
if rBullPMH
    xPMH := true
if rBearPML
    xPML := true
if rBullYH
    xYH := true
if rBearYL
    xYL := true
if rBullWH
    xWH := true
if rBearWL
    xWL := true
if rBullOH
    xOH := true
if rBearOL
    xOL := true

// ─── Raw Reversal Signals ──────────────────────────────
// Bull reversal fires at LOW levels (rejection = buy). Bear at HIGH (rejection = sell).
rRevBullPML = i_showReversal and i_showPM   and i_revPM   and bullRev(pmLow,  pmLBody)
rRevBullYL  = i_showReversal and i_showYest  and i_revYest and bullRev(yestLow, yestLBody)
rRevBullWL  = i_showReversal and i_showWeek  and i_revWeek and bullRev(weekLow, weekLBody)
rRevBullOL  = i_showReversal and i_showORB   and i_revORB  and not isORBwin and bullRev(orbLow, orbLBody)

rRevBearPMH = i_showReversal and i_showPM   and i_revPM   and bearRev(pmHigh,  pmHBody)
rRevBearYH  = i_showReversal and i_showYest  and i_revYest and bearRev(yestHigh, yestHBody)
rRevBearWH  = i_showReversal and i_showWeek  and i_revWeek and bearRev(weekHigh, weekHBody)
rRevBearOH  = i_showReversal and i_showORB   and i_revORB  and not isORBwin and bearRev(orbHigh, orbHBody)

// ─── Filtered Reversal Signals ────────────────────────
sigRevBullPML = rRevBullPML and (not i_firstOnly or not rPML)
sigRevBullYL  = rRevBullYL  and (not i_firstOnly or not rYL)
sigRevBullWL  = rRevBullWL  and (not i_firstOnly or not rWL)
sigRevBullOL  = rRevBullOL  and (not i_firstOnly or not rOL)

sigRevBearPMH = rRevBearPMH and (not i_firstOnly or not rPMH)
sigRevBearYH  = rRevBearYH  and (not i_firstOnly or not rYH)
sigRevBearWH  = rRevBearWH  and (not i_firstOnly or not rWH)
sigRevBearOH  = rRevBearOH  and (not i_firstOnly or not rOH)

// Update reversal flags
if rRevBullPML
    rPML := true
if rRevBullYL
    rYL := true
if rRevBullWL
    rWL := true
if rRevBullOL
    rOL := true
if rRevBearPMH
    rPMH := true
if rRevBearYH
    rYH := true
if rRevBearWH
    rWH := true
if rRevBearOH
    rOH := true

// ─── Combined Signals ────────────────────────────────────
anyBull     = sigBullPMH or sigBullYH or sigBullWH or sigBullOH
anyBear     = sigBearPML or sigBearYL or sigBearWL or sigBearOL
anyBreakout = anyBull or anyBear

anyRevBull  = sigRevBullPML or sigRevBullYL or sigRevBullWL or sigRevBullOL
anyRevBear  = sigRevBearPMH or sigRevBearYH or sigRevBearWH or sigRevBearOH
anyReversal = anyRevBull or anyRevBear

// ─── Signal Labels (confluent levels merged) ────────────────
bullText = ""
if sigBullPMH
    bullText := bullText + (bullText != "" ? " + " : "") + "PM H"
if sigBullYH
    bullText := bullText + (bullText != "" ? " + " : "") + "Yest H"
if sigBullWH
    bullText := bullText + (bullText != "" ? " + " : "") + "Week H"
if sigBullOH
    bullText := bullText + (bullText != "" ? " + " : "") + "ORB H"

bearText = ""
if sigBearPML
    bearText := bearText + (bearText != "" ? " + " : "") + "PM L"
if sigBearYL
    bearText := bearText + (bearText != "" ? " + " : "") + "Yest L"
if sigBearWL
    bearText := bearText + (bearText != "" ? " + " : "") + "Week L"
if sigBearOL
    bearText := bearText + (bearText != "" ? " + " : "") + "ORB L"

// Quality line: volume + close position on separate line
bullVolTrim = i_volFilter and not na(volRatioBull) ? str.tostring(volRatioBull, "#.#") + "x" : ""
bullPosTrim = i_closePos and not na(bullClosePos) ? "^" + str.tostring(bullClosePos) : ""
bullQualLine = bullVolTrim + (bullVolTrim != "" and bullPosTrim != "" ? " " : "") + bullPosTrim

bearVolTrim = i_volFilter and not na(volRatioBear) ? str.tostring(volRatioBear, "#.#") + "x" : ""
bearPosTrim = i_closePos and not na(bearClosePos) ? "v" + str.tostring(bearClosePos) : ""
bearQualLine = bearVolTrim + (bearVolTrim != "" and bearPosTrim != "" ? " " : "") + bearPosTrim

bullCount = (sigBullPMH ? 1 : 0) + (sigBullYH ? 1 : 0) + (sigBullWH ? 1 : 0) + (sigBullOH ? 1 : 0)
bearCount = (sigBearPML ? 1 : 0) + (sigBearYL ? 1 : 0) + (sigBearWL ? 1 : 0) + (sigBearOL ? 1 : 0)

// ─── Reversal/Reclaim Label Text ──────────────────────
revBullText = ""
revBullHasReclaim = false
if sigRevBullPML
    string pfx = i_showReclaim and hadBrkPML ? "~~ " : "~ "
    revBullText := revBullText + (revBullText != "" ? " + " : "") + pfx + "PM L"
    if i_showReclaim and hadBrkPML
        revBullHasReclaim := true
if sigRevBullYL
    string pfx = i_showReclaim and hadBrkYL ? "~~ " : "~ "
    revBullText := revBullText + (revBullText != "" ? " + " : "") + pfx + "Yest L"
    if i_showReclaim and hadBrkYL
        revBullHasReclaim := true
if sigRevBullWL
    string pfx = i_showReclaim and hadBrkWL ? "~~ " : "~ "
    revBullText := revBullText + (revBullText != "" ? " + " : "") + pfx + "Week L"
    if i_showReclaim and hadBrkWL
        revBullHasReclaim := true
if sigRevBullOL
    string pfx = i_showReclaim and hadBrkOL ? "~~ " : "~ "
    revBullText := revBullText + (revBullText != "" ? " + " : "") + pfx + "ORB L"
    if i_showReclaim and hadBrkOL
        revBullHasReclaim := true

revBearText = ""
revBearHasReclaim = false
if sigRevBearPMH
    string pfx = i_showReclaim and hadBrkPMH ? "~~ " : "~ "
    revBearText := revBearText + (revBearText != "" ? " + " : "") + pfx + "PM H"
    if i_showReclaim and hadBrkPMH
        revBearHasReclaim := true
if sigRevBearYH
    string pfx = i_showReclaim and hadBrkYH ? "~~ " : "~ "
    revBearText := revBearText + (revBearText != "" ? " + " : "") + pfx + "Yest H"
    if i_showReclaim and hadBrkYH
        revBearHasReclaim := true
if sigRevBearWH
    string pfx = i_showReclaim and hadBrkWH ? "~~ " : "~ "
    revBearText := revBearText + (revBearText != "" ? " + " : "") + pfx + "Week H"
    if i_showReclaim and hadBrkWH
        revBearHasReclaim := true
if sigRevBearOH
    string pfx = i_showReclaim and hadBrkOH ? "~~ " : "~ "
    revBearText := revBearText + (revBearText != "" ? " + " : "") + pfx + "ORB H"
    if i_showReclaim and hadBrkOH
        revBearHasReclaim := true

revBullCount = (sigRevBullPML ? 1 : 0) + (sigRevBullYL ? 1 : 0) + (sigRevBullWL ? 1 : 0) + (sigRevBullOL ? 1 : 0)
revBearCount = (sigRevBearPMH ? 1 : 0) + (sigRevBearYH ? 1 : 0) + (sigRevBearWH ? 1 : 0) + (sigRevBearOH ? 1 : 0)

var int lastBullSigBar = -999
var int lastBearSigBar = -999
var int lastBullLblBar = -999
var int lastBearLblBar = -999

// Scale fade threshold by TF ratio so "100 signal bars" means the same duration on any chart TF
sigTFRatio = math.max(1, timeframe.in_seconds(i_signalTF) / timeframe.in_seconds(timeframe.period))
isOld = i_fadeOld and (last_bar_index - bar_index) > i_fadeAge * sigTFRatio

revBullAlpha = revBullHasReclaim ? math.max(0, bullVolAlpha - 10) : bullVolAlpha
revBearAlpha = revBearHasReclaim ? math.max(0, bearVolAlpha - 10) : bearVolAlpha
revBullColor = color.new(color.aqua, revBullAlpha)
revBearColor = color.new(color.orange, revBearAlpha)

// ─── Combined Bull Label ─────────────────────────────────
string combinedBullText = ""
if bullText != ""
    combinedBullText := bullText
if revBullText != ""
    // Gray out prior reversal/reclaim labels at the same levels (superseded)
    if not isOld
        if sigRevBullPML and not na(revLblPML)
            label.set_color(revLblPML, color.new(color.gray, 80))
            label.set_textcolor(revLblPML, color.new(color.gray, 60))
        if sigRevBullYL and not na(revLblYL)
            label.set_color(revLblYL, color.new(color.gray, 80))
            label.set_textcolor(revLblYL, color.new(color.gray, 60))
        if sigRevBullWL and not na(revLblWL)
            label.set_color(revLblWL, color.new(color.gray, 80))
            label.set_textcolor(revLblWL, color.new(color.gray, 60))
        if sigRevBullOL and not na(revLblOL)
            label.set_color(revLblOL, color.new(color.gray, 80))
            label.set_textcolor(revLblOL, color.new(color.gray, 60))
    combinedBullText := combinedBullText + (combinedBullText != "" ? "\n" : "") + revBullText

if combinedBullText != ""
    combinedBullText += bullQualLine != "" ? "\n" + bullQualLine : ""
    // Determine color: breakout color if breakout present, reversal color if reversal-only
    color lblColor = bullText != "" ? bullColor : revBullColor
    int totalCount = bullCount + revBullCount
    // Cooldown dimming
    bool isCooled = i_cooldownBars > 0 and (sigBarIdx - lastBullSigBar) <= i_cooldownBars
    color finalColor = isCooled ? color.new(color.gray, 70) : (isOld ? color.new(color.gray, 90) : lblColor)
    color finalText = isCooled ? color.new(color.gray, 50) : (isOld ? color.new(color.gray, 70) : color.black)
    string finalSize = isCooled ? size.tiny : (totalCount > 1 ? size.normal : size.small)
    // Vertical offset for adjacent labels
    bool needsOffset = (bar_index + shapeOff - lastBullLblBar) <= 1 and lastBullLblBar >= 0

    if i_retestOnly and bullText != "" and revBullText == "" and not isOld
        // Retest-only: suppress breakout-only label, show small gray dot
        label.new(bar_index + shapeOff, na, "·",
             yloc=yloc.belowbar, style=label.style_label_up,
             color=color.new(color.gray, 80), textcolor=color.new(color.gray, 60),
             size=size.tiny)
    else
        label lbl = na
        if needsOffset and not na(dailyATR)
            lbl := label.new(bar_index + shapeOff, low - dailyATR * 0.15,
                 combinedBullText, yloc=yloc.price, style=label.style_label_up,
                 color=finalColor, textcolor=finalText, size=finalSize)
        else
            lbl := label.new(bar_index + shapeOff, na, combinedBullText,
                 yloc=yloc.belowbar, style=label.style_label_up,
                 color=finalColor, textcolor=finalText, size=finalSize)
        // Track reversal label references on the combined label
        if not isOld and revBullText != ""
            if sigRevBullPML
                revLblPML := lbl
            if sigRevBullYL
                revLblYL := lbl
            if sigRevBullWL
                revLblWL := lbl
            if sigRevBullOL
                revLblOL := lbl
        // Capture for confirmation tracking
        if i_confirm and not isOld and bullText != ""
            bRTLbl  := lbl
            bRTBase := combinedBullText

    // Update cooldown + offset trackers
    if not isOld and not isCooled
        lastBullSigBar := sigBarIdx
    if not isOld
        lastBullLblBar := bar_index + shapeOff

    // Debug append — bull breakout and/or reversal
    if (i_debugTable or i_debugLog) and not isOld
        if bullText != ""
            string prices = dbLvlPriceStr(sigBullPMH, false, sigBullYH, false, sigBullWH, false, sigBullOH, false)
            int idx = dbAppend("▲", "BRK", bullText, volRatioBull, bullClosePos, "…", prices)
            if i_confirm
                dbConfBullIdx := idx
        if revBullText != ""
            string revType = revBullHasReclaim ? "~~" : "~"
            string prices = dbLvlPriceStr(false, sigRevBullPML, false, sigRevBullYL, false, sigRevBullWL, false, sigRevBullOL)
            dbAppend("▲", revType, revBullText, volRatioBull, bullClosePos, "—", prices)

    // Confirmation setup (breakout tracking)
    if bullText != "" and i_confirm and not isOld
        // Auto-promote previous monitoring
        if bRTState == 1 and not i_retestOnly and not na(bRTLbl)
            label.set_text(bRTLbl, bRTBase + "\n✓")
            if dbConfBullIdx >= 0 and dbConfBullIdx < array.size(dbConf)
                array.set(dbConf, dbConfBullIdx, "✓")
                if i_debugLog and barstate.isconfirmed
                    log.info("[KLB] CONF {0} ▲ BRK → ✓ (auto-promote)", fmtTime(time))
        // Set up per-level tracking
        for i = 0 to 3
            array.set(bRT, i, false)
            array.set(bRTInfo, i, "")
        array.set(bRTLvl, 0, sigBullPMH ? pmHigh : na)
        array.set(bRTLvl, 1, sigBullYH  ? yestHigh : na)
        array.set(bRTLvl, 2, sigBullWH  ? weekHigh : na)
        array.set(bRTLvl, 3, sigBullOH  ? orbHigh : na)
        // Most conservative level (lowest for bull)
        float lvl = na
        if sigBullPMH
            lvl := na(lvl) ? pmHigh : math.min(lvl, pmHigh)
        if sigBullYH
            lvl := na(lvl) ? yestHigh : math.min(lvl, yestHigh)
        if sigBullWH
            lvl := na(lvl) ? weekHigh : math.min(lvl, weekHigh)
        if sigBullOH
            lvl := na(lvl) ? orbHigh : math.min(lvl, orbHigh)
        bRTConsLvl := lvl
        bRTStart   := sigBarIdx
        bRTBar0    := bar_index - 1
        bRTState   := 1

// ─── Combined Bear Label ─────────────────────────────────
string combinedBearText = ""
if bearText != ""
    combinedBearText := bearText
if revBearText != ""
    // Gray out prior reversal/reclaim labels at the same levels (superseded)
    if not isOld
        if sigRevBearPMH and not na(revLblPMH)
            label.set_color(revLblPMH, color.new(color.gray, 80))
            label.set_textcolor(revLblPMH, color.new(color.gray, 60))
        if sigRevBearYH and not na(revLblYH)
            label.set_color(revLblYH, color.new(color.gray, 80))
            label.set_textcolor(revLblYH, color.new(color.gray, 60))
        if sigRevBearWH and not na(revLblWH)
            label.set_color(revLblWH, color.new(color.gray, 80))
            label.set_textcolor(revLblWH, color.new(color.gray, 60))
        if sigRevBearOH and not na(revLblOH)
            label.set_color(revLblOH, color.new(color.gray, 80))
            label.set_textcolor(revLblOH, color.new(color.gray, 60))
    combinedBearText := combinedBearText + (combinedBearText != "" ? "\n" : "") + revBearText

if combinedBearText != ""
    combinedBearText += bearQualLine != "" ? "\n" + bearQualLine : ""
    // Determine color: breakout color if breakout present, reversal color if reversal-only
    color lblColor = bearText != "" ? bearColor : revBearColor
    int totalCount = bearCount + revBearCount
    // Cooldown dimming
    bool isCooled = i_cooldownBars > 0 and (sigBarIdx - lastBearSigBar) <= i_cooldownBars
    color finalColor = isCooled ? color.new(color.gray, 70) : (isOld ? color.new(color.gray, 90) : lblColor)
    color finalText = isCooled ? color.new(color.gray, 50) : (isOld ? color.new(color.gray, 70) : color.black)
    string finalSize = isCooled ? size.tiny : (totalCount > 1 ? size.normal : size.small)
    // Vertical offset for adjacent labels
    bool needsOffset = (bar_index + shapeOff - lastBearLblBar) <= 1 and lastBearLblBar >= 0

    if i_retestOnly and bearText != "" and revBearText == "" and not isOld
        // Retest-only: suppress breakout-only label, show small gray dot
        label.new(bar_index + shapeOff, na, "·",
             yloc=yloc.abovebar, style=label.style_label_down,
             color=color.new(color.gray, 80), textcolor=color.new(color.gray, 60),
             size=size.tiny)
    else
        label lbl = na
        if needsOffset and not na(dailyATR)
            lbl := label.new(bar_index + shapeOff, high + dailyATR * 0.15,
                 combinedBearText, yloc=yloc.price, style=label.style_label_down,
                 color=finalColor, textcolor=finalText, size=finalSize)
        else
            lbl := label.new(bar_index + shapeOff, na, combinedBearText,
                 yloc=yloc.abovebar, style=label.style_label_down,
                 color=finalColor, textcolor=finalText, size=finalSize)
        // Track reversal label references on the combined label
        if not isOld and revBearText != ""
            if sigRevBearPMH
                revLblPMH := lbl
            if sigRevBearYH
                revLblYH := lbl
            if sigRevBearWH
                revLblWH := lbl
            if sigRevBearOH
                revLblOH := lbl
        // Capture for confirmation tracking
        if i_confirm and not isOld and bearText != ""
            sRTLbl  := lbl
            sRTBase := combinedBearText

    // Update cooldown + offset trackers
    if not isOld and not isCooled
        lastBearSigBar := sigBarIdx
    if not isOld
        lastBearLblBar := bar_index + shapeOff

    // Debug append — bear breakout and/or reversal
    if (i_debugTable or i_debugLog) and not isOld
        if bearText != ""
            string prices = dbLvlPriceStr(false, sigBearPML, false, sigBearYL, false, sigBearWL, false, sigBearOL)
            int idx = dbAppend("▼", "BRK", bearText, volRatioBear, bearClosePos, "…", prices)
            if i_confirm
                dbConfBearIdx := idx
        if revBearText != ""
            string revType = revBearHasReclaim ? "~~" : "~"
            string prices = dbLvlPriceStr(sigRevBearPMH, false, sigRevBearYH, false, sigRevBearWH, false, sigRevBearOH, false)
            dbAppend("▼", revType, revBearText, volRatioBear, bearClosePos, "—", prices)

    // Confirmation setup (breakout tracking)
    if bearText != "" and i_confirm and not isOld
        // Auto-promote previous monitoring
        if sRTState == 1 and not i_retestOnly and not na(sRTLbl)
            label.set_text(sRTLbl, sRTBase + "\n✓")
            if dbConfBearIdx >= 0 and dbConfBearIdx < array.size(dbConf)
                array.set(dbConf, dbConfBearIdx, "✓")
                if i_debugLog and barstate.isconfirmed
                    log.info("[KLB] CONF {0} ▼ BRK → ✓ (auto-promote)", fmtTime(time))
        // Set up per-level tracking
        for i = 0 to 3
            array.set(sRT, i, false)
            array.set(sRTInfo, i, "")
        array.set(sRTLvl, 0, sigBearPML ? pmLow : na)
        array.set(sRTLvl, 1, sigBearYL  ? yestLow : na)
        array.set(sRTLvl, 2, sigBearWL  ? weekLow : na)
        array.set(sRTLvl, 3, sigBearOL  ? orbLow : na)
        // Most conservative level (highest for bear)
        float lvl = na
        if sigBearPML
            lvl := na(lvl) ? pmLow : math.max(lvl, pmLow)
        if sigBearYL
            lvl := na(lvl) ? yestLow : math.max(lvl, yestLow)
        if sigBearWL
            lvl := na(lvl) ? weekLow : math.max(lvl, weekLow)
        if sigBearOL
            lvl := na(lvl) ? orbLow : math.max(lvl, orbLow)
        sRTConsLvl := lvl
        sRTStart   := sigBarIdx
        sRTBar0    := bar_index - 1
        sRTState   := 1

// ─── Per-Level Retest Monitoring ─────────────────────────
// Runs every signal-TF bar for chart-TF independent monitoring.
// Helper: build retest suffix lines from per-level arrays
buildRetestSuffix(bool[] rt, int[] rtBar, string[] rtInfo, float[] rtLvl, string[] names, int startBar, bool isBull) =>
    string suffix = ""
    for i = 0 to 3
        if array.get(rt, i) and not na(array.get(rtLvl, i))
            int bars = array.get(rtBar, i) - startBar
            string line = "◆" + toSup(bars) + " " + array.get(names, i)
            string qi = array.get(rtInfo, i)
            if qi != ""
                line += " " + qi
            suffix += "\n" + line
    suffix

// Bull retest monitoring (chart-TF precision)
if i_confirm and bRTState == 1 and not na(bRTConsLvl) and isRegular
    int elapsed = sigBarIdx - bRTStart
    if close < bRTConsLvl - rearmBuf
        bRTState := -1
        if not na(bRTLbl)
            label.set_text(bRTLbl, bRTBase + "\n✗")
            label.set_color(bRTLbl, color.new(color.gray, 60))
            label.set_textcolor(bRTLbl, color.new(color.gray, 40))
        if dbConfBullIdx >= 0 and dbConfBullIdx < array.size(dbConf)
            array.set(dbConf, dbConfBullIdx, "✗")
            if i_debugLog and barstate.isconfirmed
                log.info("[KLB] CONF {0} ▲ BRK → ✗ (failed)", fmtTime(time))
    else
        bool anyNew = false
        for i = 0 to 3
            float lvl = array.get(bRTLvl, i)
            if not na(lvl) and not array.get(bRT, i) and bar_index > bRTBar0
                if low <= lvl + retestBuf and close > lvl - rearmBuf
                    array.set(bRT, i, true)
                    array.set(bRTBar, i, sigBarIdx)
                    array.set(bRTInfo, i, chartQual(true))
                    anyNew := true
        if anyNew
            string suffix = buildRetestSuffix(bRT, bRTBar, bRTInfo, bRTLvl, bullLvlNames, bRTStart, true)
            string rtText = str.substring(suffix, 1)  // skip leading \n
            // Independent retest label + alert (always, unless old)
            if not isOld
                label.new(bar_index, na, rtText,
                     yloc=yloc.belowbar, style=label.style_label_up,
                     color=bullColor, textcolor=color.black, size=size.small)
                alert("Retest: " + rtText, alert.freq_once_per_bar_close)
                // Debug: log retest
                if i_debugTable or i_debugLog
                    dbAppend("▲", "◆", rtText, na, na, "—", "")
            // Also update original breakout label (unless retest-only mode)
            if not i_retestOnly and not na(bRTLbl)
                label.set_text(bRTLbl, bRTBase + suffix)
        if elapsed >= retestMaxElapsed and bRTState == 1
            if dbConfBullIdx >= 0 and dbConfBullIdx < array.size(dbConf) and array.get(dbConf, dbConfBullIdx) == "…"
                array.set(dbConf, dbConfBullIdx, "✓")
                if i_debugLog and barstate.isconfirmed
                    log.info("[KLB] CONF {0} ▲ BRK → ✓ (window)", fmtTime(time))
            bRTState := 0

// Bear retest monitoring (chart-TF precision)
if i_confirm and sRTState == 1 and not na(sRTConsLvl) and isRegular
    int elapsed = sigBarIdx - sRTStart
    if close > sRTConsLvl + rearmBuf
        sRTState := -1
        if not na(sRTLbl)
            label.set_text(sRTLbl, sRTBase + "\n✗")
            label.set_color(sRTLbl, color.new(color.gray, 60))
            label.set_textcolor(sRTLbl, color.new(color.gray, 40))
        if dbConfBearIdx >= 0 and dbConfBearIdx < array.size(dbConf)
            array.set(dbConf, dbConfBearIdx, "✗")
            if i_debugLog and barstate.isconfirmed
                log.info("[KLB] CONF {0} ▼ BRK → ✗ (failed)", fmtTime(time))
    else
        bool anyNew = false
        for i = 0 to 3
            float lvl = array.get(sRTLvl, i)
            if not na(lvl) and not array.get(sRT, i) and bar_index > sRTBar0
                if high >= lvl - retestBuf and close < lvl + rearmBuf
                    array.set(sRT, i, true)
                    array.set(sRTBar, i, sigBarIdx)
                    array.set(sRTInfo, i, chartQual(false))
                    anyNew := true
        if anyNew
            string suffix = buildRetestSuffix(sRT, sRTBar, sRTInfo, sRTLvl, bearLvlNames, sRTStart, false)
            string rtText = str.substring(suffix, 1)  // skip leading \n
            // Independent retest label + alert (always, unless old)
            if not isOld
                label.new(bar_index, na, rtText,
                     yloc=yloc.abovebar, style=label.style_label_down,
                     color=bearColor, textcolor=color.black, size=size.small)
                alert("Retest: " + rtText, alert.freq_once_per_bar_close)
                // Debug: log retest
                if i_debugTable or i_debugLog
                    dbAppend("▼", "◆", rtText, na, na, "—", "")
            // Also update original breakout label (unless retest-only mode)
            if not i_retestOnly and not na(sRTLbl)
                label.set_text(sRTLbl, sRTBase + suffix)
        if elapsed >= retestMaxElapsed and sRTState == 1
            if dbConfBearIdx >= 0 and dbConfBearIdx < array.size(dbConf) and array.get(dbConf, dbConfBearIdx) == "…"
                array.set(dbConf, dbConfBearIdx, "✓")
                if i_debugLog and barstate.isconfirmed
                    log.info("[KLB] CONF {0} ▼ BRK → ✓ (window)", fmtTime(time))
            sRTState := 0

// Retest state transition alerts
if i_confirm
    if bRTState != bRTPrev
        if bRTState == -1
            alert("Failed: " + bRTBase, alert.freq_once_per_bar_close)
        bRTPrev := bRTState
    if sRTState != sRTPrev
        if sRTState == -1
            alert("Failed: " + sRTBase, alert.freq_once_per_bar_close)
        sRTPrev := sRTState

// ─── Debug Signal Table ──────────────────────────────
if i_debugTable and barstate.islast
    posMap = i_debugPos == "top_left" ? position.top_left :
             i_debugPos == "top_center" ? position.top_center :
             i_debugPos == "top_right" ? position.top_right :
             i_debugPos == "bottom_left" ? position.bottom_left :
             i_debugPos == "bottom_center" ? position.bottom_center :
             position.bottom_right

    if not na(dbTbl)
        table.delete(dbTbl)

    int totalRows = array.size(dbTime)
    int startIdx  = math.max(0, totalRows - i_debugRows)
    int showRows  = totalRows - startIdx

    dbTbl := table.new(posMap, 8, showRows + 1,
         bgcolor=color.new(color.black, 80), border_width=1,
         border_color=color.new(color.gray, 60))

    // Header row
    table.cell(dbTbl, 0, 0, "Time",  text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.gray, 30))
    table.cell(dbTbl, 1, 0, "Dir",   text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.gray, 30))
    table.cell(dbTbl, 2, 0, "Type",  text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.gray, 30))
    table.cell(dbTbl, 3, 0, "Levels",text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.gray, 30))
    table.cell(dbTbl, 4, 0, "Vol",   text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.gray, 30))
    table.cell(dbTbl, 5, 0, "Pos",   text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.gray, 30))
    table.cell(dbTbl, 6, 0, "Conf",  text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.gray, 30))
    table.cell(dbTbl, 7, 0, "OHLC",  text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.gray, 30))

    // Data rows
    for i = startIdx to totalRows - 1
        int row = i - startIdx + 1
        string dir  = array.get(dbDir, i)
        string typ  = array.get(dbType, i)
        string conf = array.get(dbConf, i)
        bool isBull = dir == "▲"
        bool isFailed = conf == "✗"

        // Row background color
        color rowBg = isFailed ? color.new(color.gray, 85) :
             typ == "BRK" ? (isBull ? color.new(color.green, 88) : color.new(color.red, 88)) :
             typ == "~" or typ == "~~" ? (isBull ? color.new(color.aqua, 88) : color.new(color.orange, 88)) :
             color.new(color.black, 88)
        color rowTxt = isFailed ? color.new(color.gray, 40) : color.white

        string timeStr = fmtTime(array.get(dbTime, i))
        float vol = array.get(dbVol, i)
        string volStr = not na(vol) ? str.tostring(vol, "#.#") + "x" : "—"
        int pos = array.get(dbClsPos, i)
        string posStr = na(pos) ? "—" : (isBull ? "^" : "v") + str.tostring(pos)

        table.cell(dbTbl, 0, row, timeStr,                    text_color=rowTxt, text_size=size.tiny, bgcolor=rowBg)
        table.cell(dbTbl, 1, row, dir,                         text_color=isBull ? color.green : color.red, text_size=size.tiny, bgcolor=rowBg)
        table.cell(dbTbl, 2, row, typ,                         text_color=rowTxt, text_size=size.tiny, bgcolor=rowBg)
        table.cell(dbTbl, 3, row, array.get(dbLevels, i),     text_color=rowTxt, text_size=size.tiny, bgcolor=rowBg, text_halign=text.align_left)
        table.cell(dbTbl, 4, row, volStr,                      text_color=rowTxt, text_size=size.tiny, bgcolor=rowBg)
        table.cell(dbTbl, 5, row, posStr,                      text_color=rowTxt, text_size=size.tiny, bgcolor=rowBg)
        table.cell(dbTbl, 6, row, conf,                        text_color=conf == "✓" ? color.lime : conf == "✗" ? color.red : color.gray, text_size=size.tiny, bgcolor=rowBg)
        table.cell(dbTbl, 7, row, array.get(dbOHLC, i),       text_color=rowTxt, text_size=size.tiny, bgcolor=rowBg, text_halign=text.align_left)

// ─── Level Lines (optional, off by default) ───────────────
pPMH  = plot(i_showLines and i_showPM   and isRegular ? pmHigh   : na, "PM High",   color.new(color.orange, 40), 1, plot.style_linebr)
pPML  = plot(i_showLines and i_showPM   and isRegular ? pmLow    : na, "PM Low",    color.new(color.orange, 40), 1, plot.style_linebr)
pYH   = plot(i_showLines and i_showYest and isRegular ? yestHigh : na, "Yest High", color.new(color.blue, 40),   1, plot.style_linebr)
pYL   = plot(i_showLines and i_showYest and isRegular ? yestLow  : na, "Yest Low",  color.new(color.blue, 40),   1, plot.style_linebr)
pWH   = plot(i_showLines and i_showWeek and isRegular ? weekHigh : na, "Week High", color.new(color.purple, 40), 1, plot.style_linebr)
pWL   = plot(i_showLines and i_showWeek and isRegular ? weekLow  : na, "Week Low",  color.new(color.purple, 40), 1, plot.style_linebr)
pOH   = plot(i_showLines and i_showORB  and isRegular ? orbHigh  : na, "ORB High",  color.new(color.teal, 40),   1, plot.style_linebr)
pOL   = plot(i_showLines and i_showORB  and isRegular ? orbLow   : na, "ORB Low",   color.new(color.teal, 40),   1, plot.style_linebr)

// ─── Zone Band Visualization ──────────────────────────────
// Body-edge plots (hidden lines used as fill boundary)
showZones = i_showLines and i_useZones
pPMHb = plot(showZones and i_showPM   and isRegular ? pmHBody   : na, "PM High Body",   color.new(color.orange, 100), 1, plot.style_linebr, display=display.none)
pPMLb = plot(showZones and i_showPM   and isRegular ? pmLBody   : na, "PM Low Body",    color.new(color.orange, 100), 1, plot.style_linebr, display=display.none)
pYHb  = plot(showZones and i_showYest and isRegular ? yestHBody : na, "Yest High Body", color.new(color.blue, 100),   1, plot.style_linebr, display=display.none)
pYLb  = plot(showZones and i_showYest and isRegular ? yestLBody : na, "Yest Low Body",  color.new(color.blue, 100),   1, plot.style_linebr, display=display.none)
pWHb  = plot(showZones and i_showWeek and isRegular ? weekHBody : na, "Week High Body", color.new(color.purple, 100), 1, plot.style_linebr, display=display.none)
pWLb  = plot(showZones and i_showWeek and isRegular ? weekLBody : na, "Week Low Body",  color.new(color.purple, 100), 1, plot.style_linebr, display=display.none)
pOHb  = plot(showZones and i_showORB  and isRegular ? orbHBody  : na, "ORB High Body",  color.new(color.teal, 100),   1, plot.style_linebr, display=display.none)
pOLb  = plot(showZones and i_showORB  and isRegular ? orbLBody  : na, "ORB Low Body",   color.new(color.teal, 100),   1, plot.style_linebr, display=display.none)

// Zone fills between wick line and body-edge line
fill(pPMH, pPMHb, color=color.new(color.orange, 85), title="PM High Zone")
fill(pPML, pPMLb, color=color.new(color.orange, 85), title="PM Low Zone")
fill(pYH,  pYHb,  color=color.new(color.blue, 85),   title="Yest High Zone")
fill(pYL,  pYLb,  color=color.new(color.blue, 85),   title="Yest Low Zone")
fill(pWH,  pWHb,  color=color.new(color.purple, 85), title="Week High Zone")
fill(pWL,  pWLb,  color=color.new(color.purple, 85), title="Week Low Zone")
fill(pOH,  pOHb,  color=color.new(color.teal, 85),   title="ORB High Zone")
fill(pOL,  pOLb,  color=color.new(color.teal, 85),   title="ORB Low Zone")

// ─── Programmatic Alerts (merged like labels) ───────────
if bullText != "" and not i_retestOnly
    alert("Bullish breakout: " + bullText + " " + bullQualLine, alert.freq_once_per_bar_close)
if bearText != "" and not i_retestOnly
    alert("Bearish breakout: " + bearText + " " + bearQualLine, alert.freq_once_per_bar_close)
if revBullText != ""
    alert("Bullish reversal: " + revBullText + " " + bullQualLine, alert.freq_once_per_bar_close)
if revBearText != ""
    alert("Bearish reversal: " + revBearText + " " + bearQualLine, alert.freq_once_per_bar_close)

// ─── Alert Conditions ───────────────────────────────────────
// Note: per-level alertconditions removed — "Any alert() function call"
// catches both alert() and alertcondition(), causing duplicate notifications.
// Use "Any alert() function call" for merged alerts (recommended).
// Use the conditions below for simple bull/bear/any filtering.
alertcondition(anyBull,     "Any Bullish Breakout",       "Bullish breakout detected")
alertcondition(anyBear,     "Any Bearish Breakout",       "Bearish breakout detected")
alertcondition(anyBreakout, "Any Breakout",               "Breakout detected (bull or bear)")
alertcondition(anyRevBull,  "Any Bullish Reversal",       "Bullish reversal detected")
alertcondition(anyRevBear,  "Any Bearish Reversal",       "Bearish reversal detected")
alertcondition(anyReversal, "Any Reversal",               "Reversal detected (bull or bear)")
alertcondition(anyBreakout or anyReversal, "Any Setup",   "Breakout or reversal detected")
